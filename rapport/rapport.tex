\documentclass[a4paper,11pt]{article}

\usepackage[francais]{babel}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{hyperref}
\usepackage{color}
\usepackage{fancyheadings}
\usepackage{lastpage}
\usepackage{fullpage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\reporttitle}{Attaques timings contre les caches des CPU} % titre en français
\newcommand{\reportauthor}{Jean BAUDINAT, Chloé MACUR}
\newcommand{\reportdate}{\today}

\lhead{}
\rhead{\leftmark \rightmark}
\cfoot{Page \thepage/\pageref{LastPage}}


\begin{document}	

\begin{center}

\begin{minipage}[t]{0.4\textwidth}
  \begin{flushleft} \large
    \reportauthor
  \vfill
  \end{flushleft}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
  \begin{flushright}
  \includegraphics [width=20mm]{figures/tpt.jpg}
  \end{flushright}
\end{minipage}
\HRule \\[0.4cm]
{\huge \bfseries \reporttitle}\\[0.1cm]
\HRule \\
\end{center}

L'utilisation des caches des CPU modifie le temps d'accès à une donnée selon si elle est présente dans le cache ou non. Un attaquant peut alors en tirer des informations et ainsi réaliser une attaque par canal auxiliaire.

\section{Fonctionnement du cache}

Le but du cache est d'accélérer les calculs du processeurs en outrepassant les facteurs limitants que sont la vitesse d'accès à la mémoire ainsi que la bande passante du bus. Au lieu d'accéder à la mémoire via des \emph{load/store}, on accède à une copie des données située dans une mémoire rapide.

Lorsque les données auxquelles on souhaite accéder sont présentes dans le cache, on y accède directement sans accès mémoire, on parle alors de \emph{cache hit}. Dans le cas d'un \emph{cache miss} (donnée absente du cache) on va donc accéder à la mémoire et mettre à jour le cache.
  
\begin{figure}[h]
  \centering
  \includegraphics[width=8cm]{figures/cache_associative.png}
  \caption{Caches associatifs par blocs (\emph{4-way set associative})}
  \label{cache} 
\end{figure}

Comme présenté dans la figure \ref{cache}, un cache associatif par blocs est constitué de blocs qui contiennent des lignes. Pour identifier une adresse dans le cache on a donc besoin: d'un index (numéro de ligne à tester), de l'adresse dans la ligne (offset du contenu) et d'une étiquette que l'on va comparer avec le contenu de la ligne. On récupère ainsi la valeur désirée dans le cache. 

Lorsqu'un \emph{cache miss} a lieu et que l'on ajoute un contenu dans le cache, s'il n'existe pas de ligne vide on supprime entièrement celle qui a été utilisée le moins récemment (\emph{Least Recently Used, LRU}). On ne récupère pas uniquement les données demandées, mais un mot de taille fixe qui contient les données adjacentes. On notera ainsi qu'en fonction des paramètres du cache (nombre et taille des blocs, taille des mots) et de l'état initial de celui-ci, les données stockées en cache seront différentes.\\

Le principe du cache étant d'accélérer l'accès aux données, l'accès à la mémoire ne se fait pas en temps constant\footnote{Sur un processeur de 2010, un accès au cache L1 se fait en 0.3ns contre 50 à 150ns pour la mémoire principale~\cite{tromer2010efficient}.}. L'utilisation du cache va donc à la fois modifier la latence et la consommation électrique, permettant à un attaquant d'en déduire l'existence de \emph{cache hit} ou de \emph{cache miss} et ainsi repérer des patterns d'accès à la mémoire et apprendre des informations sur le chiffrement.

%TODO réferences? Mon cours d'architecture ..


\section{Fonctionnement de l'attaque : l'exemple d'AES}

\paragraph{Vulnérabilité d'AES}
Nous allons illustrer la \emph{Cache Timing Attack} en expliquant comment ce type d'attaque peut être mis en œuvre pour casser une implémentation logicielle d'AES. En effet, l'attaque d'AES est l'exemple le plus référencé dans la littérature de ce type d'attaque.

L'attaque d'AES par \emph{Cache Timing Attack} repose sur le stockage en dur des boîtes S dans la mémoire. Ces boîtes S sont utilisées dans l'opération \emph{SubByte} et sont une permutation linéaire de $ GF(256) = GF(2)[x]/(x^8+x^4+x^3+x+1) $ dans lui même. En effet, à des fins de rapidité, ces boîtes S ne sont pas recalculées en permanence. Elles sont donc stockées en mémoire dans des \emph{Lookup Tables}, et leur utilisation implique leur stockage dans le cache. Les \emph{Lookup Tables} correspondent aux valeurs des boîtes S correspondant à certaines valeurs de clé. Ainsi, l'algorithme peut gagner en rapidité en évitant de charger dans le cache l'intégralité des boîtes S, alors que seule une partie sera utilisée lors du chiffrement. Cependant ces \emph{Lookup Tables} dépendant de la clé, y accéder donne de l'information à l'attaquant et lui permet d'exclure certaines valeurs de clé ne nécessitant pas d'accéder aux \emph{Lookup Tables} chargées en mémoire.

\paragraph{Types d'attaques}
Les \emph{Timing Cache Attack} sont donc des attaques de type canal auxiliaire se basant sur la mesure du temps d'accès à une donnée, selon qu'elle a déjà été stockée dans le cache ou non. On peut distinguer 3 types d'attaques \cite{aciiccmez2006trace}, respectivement basées sur le temps, les traces ou l'accès mémoire.
Pour être mises en places, ces attaques supposent que la phase de chiffrement est clairement identifiée. On suppose donc que l'adversaire est en mesure d'identifier un changement de contexte, et donc de ne pas utiliser les mesures touchées par ce phénomène. %TODO je comprends pas cette phrase " ne pas utiliser les mesures touchées par ce phénomène"
On suppose de plus que le cache est assez grand pour contenir toutes les informations nécessaires au chiffrement, ce qui est le cas de la plupart des processeurs récents.

L'attaque basée sur le temps (\emph{time driven attack}) repose sur la mesure agrégée du temps de chiffrement. Connaissant la plateforme de chiffrement, l'attaquant est alors en mesure de savoir le nombre de \emph{hit} et de \emph{miss} ayant eu lieu lors de l'opération de chiffrement.
L'attaque basée sur les traces \emph{Trace Driven Attack} est plus précise. L'attaquant peut savoir quand un \emph{hit} ou un \emph{miss} ont lieu. %TODO pourquoi. Détailler
Enfin, l'attaque basée sur l'accès \emph{Access Driven Attack} permet de connaître précisément les \emph{lookup tables} auxquelles l'attaquant a pu avoir accès. %TODO détailler, là on donne juste un nom sans rien expliquer
 
%TODO one round two rounds

\section{Contre-mesures} %TODO séparer en deux parties, ça n'a aucun sens de parler de "contre-mesures" alors qu'on évoque d'autres attaques un peu plus poussées

La réalisation de ces attaques contre les caches présente en réalité un certain nombre de difficultés pour l'attaquant. On distinguera dans un premier temps les difficultés qui sont inhérentes à la méthode et qui nécessitent une adaptation de la part de l'attaquant. On présentera ensuite des contre-mesures actives implémentées pour rendre l'attaque plus difficile voire impossible à réaliser.

\subsection{Difficultés inhérentes à la méthode}

Les résultats obtenus lors de l'attaque dépendent évidemment de l'architecture considérée, des opportunités qu'a l'attaquant de manipuler le cache, mais également de l'état initial du cache et de la séquence d'accès à la mémoire. 

Ainsi il est primordial pour l'attaquant de se placer dans des conditions telles qu'il connaisse l'état initial du cache. Il existe principalement trois états initiaux auxquels il peut se ramener~\cite{canteaut2006understanding}:
\begin{itemize}
\item le cache ne contient pas de tables utiles pour le chiffrement (cache flush, par exemple en coupant l'alimentation)
\item le cache est rempli par l'attaquant (nécessite un accès au cache et donc un système multi utilisateurs) 
\item le cache contient déjà toutes les tables nécessaires au chiffrement. Cette solution devrait permettre un accès en temps constant à toutes les données, rendant l'attaque difficile. En réalité il subsiste des variations de latence lors de l'exécution de l'algorithme, principalement à cause des conflits dus à des accès concurrents. Par ailleurs, la taille du cache, son architecture ou encore la politique de remplacement peuvent donner lieu à l'éviction de certaines données, et ainsi recréer des \emph{cache miss}.
\end{itemize}


On distingue deux types d'attaques selon ce que l'attaquant connaît~\cite{osvik2006cache}. Les attaques dites synchrones supposent que celui-ci peut attaquer en même temps que le chiffrement à lieu et sur le même processeur, lui permettant de connaître des textes clairs. Par exemple un \emph{VPN} (\emph{Virtual Private Network}) peut autoriser un utilisateur lambda à envoyer des paquets. L'attaquant envoie alors des demandes de chiffrement forgées de toutes pièces, lui permettant d'obtenir des informations sur la clé. 

Si jamais l'attaquant ne peut pas communiquer avec le processus de chiffrement, il peut tout de même réaliser une attaque dite asynchrone. Ce type d'attaque nécessite une bonne connaissance de l'architecture considérée, mais permet d'obtenir de très bons résultats %TODO En cous d'écriture
 Les prérequis sont alors de pouvoir exécuter un programme sur le même processeur (sans interaction nécessaire), et que la distribution des textes clairs et chiffrés soit non uniforme. En observant les accès à sa propre mémoire, l'attaquant peut alors identifier des patterns d'accès à la mémoire réalisés par  les autres processus. multithreading.

\paragraph{mesure du temps:} facile si multithread. Différentes méthodes: statistiques (nécessite de bien connaître l'archi), ou bien on crée un cache hit et on mesure, puis on crée un cache miss et on mesure. %TODO C

\paragraph{présence de bruit:} rend difficile la récupération des traces du chiffrement et donc .. %C

\subsection{Evolution des technologies}
L'évolution des technologies matérielles rend désormais la \emph{Timing Cache Attack} plus difficile à mettre en \oe uvre.

\paragraph{Une attaque sur x86 plus difficile}
Mowery~\cite{mowery2012aes} cite des évolutions matérielles rendant plus difficile voir impossible la mise en œuvre de l'attaque d'AES. Parmi celles-ci, on compte notamment le nouveau jeu d'instruction des processeurs Intel : AES-NI. Ce jeu d'instruction permet de traiter matériellement sur un composant dédié du processeur le chiffrement AES. Ainsi, il n'est plus du tout fait usage du cache. Le clair est chargé, et le chiffré est calculé sans aucune autre interaction avec la mémoire ou le cache.
Cette innovation a été suivie par d'autres fondeurs. Un processeur possédant ce type de composant sera donc virtuellement à l'abri de ce type d'attaque. Cependant, encore faut-il que l'implémentation d'AES utilise le bon jeu d'instructions, ce qui n'est pas toujours le cas.

\paragraph{Une évolution des technologies créatrice de difficultés supplémentaires}

\begin{figure}[h]
  \centering
  \includegraphics[width=14cm]{figures/BDArch.png}
  \caption{Étagement des caches dans un processeur quadricoeur}
  \label{etagement} 
\end{figure}

L'évolution des technologies actuelles a entraîné l'apparition de deux phénomènes. Tout d'abord, les processeurs sont désormais multicœurs, ce qui leur permet de faire tourner plusieurs processus en même temps. Cette évolution, destinée à accélérer le traitement des données a également des répercussion sur la mise en place de la \emph{Cache Timing Attack}\cite{weiss2012cache}. Dans le cas du processeur quadricœur d'Intel  présenté sur la Figure \ref{etagement} par exemple, chaque cœur possède deux \emph{threads} possédant chacun leur cache L3. Le cœur lui même possède son cache L2. Enfin, l'ensemble du processeur possède un cache L1. Cette multiplication des caches en étage complexifie bien sûr l'attaque, puisqu'elle occasionne plus de bruit dans la mesure des \emph{hit} ou \emph{miss} intéressants, d'autant plus que les caches L3 et L2 sont corrompus par les processus tournant sur les autres cœurs et \emph{threads}.
Une autre évolution réside dans la virtualisation des tâches, tendant à séparer les processus et les contextes. \cite{weiss2012cache}. Cependant, l'attaque exploitant les caches est dans ces cas une des seules qui puisse être mise en oeuvre depuis un environnement non sécurisé vers un environnement sécurisé. C'est par exemple le cas sur les environnement de type téléphone mobile, où l'OS et l'environnement sécurisé effectuant les opérations de cryptographie sont séparés par de la virtualisation. Cependant, un attaquant corrompant l'OS (à l'aide d'un cheval de Troie par exemple) pourra par la suite mener une \emph{Cache Timing Attack} contre l'environnement sécurisé, le cache étant partagé malgré la virtualisation.

\subsection{Contre-mesures avancées}


\section{Contournements}
Attaques à l'heure actuelle : mise en place, contournement des contre-mesures %TODO

\section*{Conclusion}
%TODO

\newpage
\nocite{*}
\bibliographystyle{plain}
\bibliography{ref}


\end{document}
